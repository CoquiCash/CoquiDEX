
export function* loadBuyCoinProcess({ payload }) {
  try {
    // step one: load user data
    const user = yield select(makeSelectCurrentUser());
    if (!user) {
      throw new Error('not found user');
    }
    const { basecoin, paymentcoin, amount } = payload;

    const userpass = user.get('userpass');
    // const coins = user.get('coins');
    // const smartaddress = coins.find(c => c.get('coin') === paymentcoin);

    // step two: load balance
    const balances = yield select(makeSelectBalanceEntities());
    const balance = balances.find(c => c.get('coin') === paymentcoin);

    // step three: load best price
    const prices = yield select(makeSelectPricesEntities());
    const price = prices.find(c => c.get('rel') === paymentcoin);

    // step four: check balance
    const relvolume = Number(amount * price.get('price'));
    if (
      relvolume * numcoin + txfee >=
      Number(balance.get('balance') * numcoin).toFixed(0)
    ) {
      throw new Error('Not enough balance!');
    }

    // step one: get listUnspent data
    // const unspent = yield api.listUnspent({
    //   userpass,
    //   coin: paymentcoin,
    //   address: smartaddress.get('smartaddress')
    // });
    // console.log('loadBuyCoinProcess', unspent);

    // step xxx: buy
    const buyparams = {
      userpass,
      base: basecoin,
      rel: paymentcoin,
      relvolume: relvolume.toFixed(8),
      price: price.get('bestPrice').toFixed(8)
    };

    const result = yield api.buy(buyparams);
    if (result.pending) {
      return yield put(loadBuyCoinSuccess(result.pending));
    }
    if (result.error) {
      return yield put(loadBuyCoinError(result.error));
    }
  } catch (err) {
    // FIXME: handling error
    return yield put(loadBuyCoinError(err.message));
  }
}
